!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
APPEND_INDENT	src/parson.c	1028;"	d	file:
APPEND_INDENT	src/parson.c	790;"	d	file:
APPEND_STRING	src/parson.c	1027;"	d	file:
APPEND_STRING	src/parson.c	785;"	d	file:
APP_NAME	Makefile	/^APP_NAME := dragino_gw_fwd$/;"	m
AR	Makefile	/^AR := $(CROSS_COMPILE)ar$/;"	m
ARCH	Makefile	/^ARCH ?=$/;"	m
ARRAY_MAX_CAPACITY	src/parson.c	38;"	d	file:
ARRAY_SIZE	src/base64.c	28;"	d	file:
ARRAY_SIZE	src/dragino_gw_fwd.c	79;"	d	file:
ARRAY_SIZE	src/gwtraf_transport.c	72;"	d	file:
ARRAY_SIZE	src/semtech_transport.c	72;"	d	file:
BEACON_GUARD	src/jitqueue.c	42;"	d	file:
BEACON_POLL_MS	src/dragino_gw_fwd.c	101;"	d	file:
BEACON_QUEUED	inc/stats.h	/^	BEACON_QUEUED,$/;"	e	enum:stats_down
BEACON_REJECTED	inc/stats.h	/^	BEACON_REJECTED$/;"	e	enum:stats_down
BEACON_RESERVED	src/jitqueue.c	44;"	d	file:
BEACON_SENT	inc/stats.h	/^	BEACON_SENT,$/;"	e	enum:stats_down
CC	Makefile	/^CC := $(CROSS_COMPILE)gcc$/;"	m
CFLAGS	Makefile	/^CFLAGS ?=$/;"	m
CFLAGS_C	Makefile	/^CFLAGS_C := -fPIC -O2 -Wall -Wextra -Iinc -I.$/;"	m
CLOCK_MONOTONIC	inc/dragino_gw_fwd.h	18;"	d
CLOCK_REALTIME	inc/dragino_gw_fwd.h	17;"	d
CRIT	src/base64.c	29;"	d	file:
CROSS_COMPILE	Makefile	/^CROSS_COMPILE ?=$/;"	m
DEBUG	src/base64.c	32;"	d	file:
DEBUG_BEACON	inc/trace.h	23;"	d
DEBUG_ERROR	inc/trace.h	27;"	d
DEBUG_FOLLOW	inc/trace.h	25;"	d
DEBUG_INFO	inc/trace.h	26;"	d
DEBUG_JIT	inc/trace.h	20;"	d
DEBUG_JIT_ERROR	inc/trace.h	21;"	d
DEBUG_LOG	inc/trace.h	24;"	d
DEBUG_PKT_FWD	inc/trace.h	19;"	d
DEBUG_TIMERSYNC	inc/trace.h	22;"	d
DEFAULT_KEEPALIVE	src/dragino_gw_fwd.c	95;"	d	file:
DEFAULT_KEEPALIVE	src/gwtraf_transport.c	81;"	d	file:
DEFAULT_KEEPALIVE	src/semtech_transport.c	81;"	d	file:
DEFAULT_PORT_DW	src/dragino_gw_fwd.c	94;"	d	file:
DEFAULT_PORT_UP	src/dragino_gw_fwd.c	93;"	d	file:
DEFAULT_SERVER	src/dragino_gw_fwd.c	92;"	d	file:
DEFAULT_STAT	src/dragino_gw_fwd.c	96;"	d	file:
DISPLAY_PLATFORM	src/dragino_gw_fwd.c	89;"	d	file:
DOUBLE_SERIALIZATION_FORMAT	inc/parson.h	35;"	d
ENDIANEXT_H_	inc/endianext.h	12;"	d
FETCH_SLEEP_MS	src/dragino_gw_fwd.c	100;"	d	file:
GHOST_DATA	src/ghost.c	46;"	d	file:
GHST_MIN_PACKETSIZE	inc/ghost.h	32;"	d
GHST_NM_RCV	inc/ghost.h	36;"	d
GHST_REQ_BUFFSIZE	inc/ghost.h	33;"	d
GHST_RX_BUFFSIZE	inc/ghost.h	34;"	d
GHST_TX_BUFFSIZE	inc/ghost.h	35;"	d
GPS_REF_MAX_AGE	src/dragino_gw_fwd.c	99;"	d	file:
INCLUDES	Makefile	/^INCLUDES = $(wildcard inc\/*.h)$/;"	m
IS_CONT	src/parson.c	53;"	d	file:
JIT_ERROR_COLLISION_BEACON	inc/jitqueue.h	/^	JIT_ERROR_COLLISION_BEACON,	\/* A beacon is planned for this timeframe *\/$/;"	e	enum:jit_error_e
JIT_ERROR_COLLISION_PACKET	inc/jitqueue.h	/^	JIT_ERROR_COLLISION_PACKET,	\/* A packet is already enqueued for this timeframe *\/$/;"	e	enum:jit_error_e
JIT_ERROR_EMPTY	inc/jitqueue.h	/^	JIT_ERROR_EMPTY,			\/* Downlink queue is empty *\/$/;"	e	enum:jit_error_e
JIT_ERROR_FULL	inc/jitqueue.h	/^	JIT_ERROR_FULL,				\/* Downlink queue is full *\/$/;"	e	enum:jit_error_e
JIT_ERROR_GPS_UNLOCKED	inc/jitqueue.h	/^	JIT_ERROR_GPS_UNLOCKED,		\/* GPS timestamp could not be used as GPS is unlocked *\/$/;"	e	enum:jit_error_e
JIT_ERROR_INVALID	inc/jitqueue.h	/^	JIT_ERROR_INVALID			\/* Packet is invalid *\/$/;"	e	enum:jit_error_e
JIT_ERROR_OK	inc/jitqueue.h	/^	JIT_ERROR_OK,				\/* Packet ok to be sent *\/$/;"	e	enum:jit_error_e
JIT_ERROR_TOO_EARLY	inc/jitqueue.h	/^	JIT_ERROR_TOO_EARLY,		\/* Too early to queue this packet *\/$/;"	e	enum:jit_error_e
JIT_ERROR_TOO_LATE	inc/jitqueue.h	/^	JIT_ERROR_TOO_LATE,			\/* Too late to send this packet *\/$/;"	e	enum:jit_error_e
JIT_ERROR_TX_FREQ	inc/jitqueue.h	/^	JIT_ERROR_TX_FREQ,			\/* The required frequency for downlink is not supported *\/$/;"	e	enum:jit_error_e
JIT_ERROR_TX_POWER	inc/jitqueue.h	/^	JIT_ERROR_TX_POWER,			\/* The required power for downlink is not supported *\/$/;"	e	enum:jit_error_e
JIT_NUM_BEACON_IN_QUEUE	inc/jitqueue.h	33;"	d
JIT_PKT_TYPE_BEACON	inc/jitqueue.h	/^	JIT_PKT_TYPE_BEACON$/;"	e	enum:jit_pkt_type_e
JIT_PKT_TYPE_DOWNLINK_CLASS_A	inc/jitqueue.h	/^	JIT_PKT_TYPE_DOWNLINK_CLASS_A,$/;"	e	enum:jit_pkt_type_e
JIT_PKT_TYPE_DOWNLINK_CLASS_B	inc/jitqueue.h	/^	JIT_PKT_TYPE_DOWNLINK_CLASS_B,$/;"	e	enum:jit_pkt_type_e
JIT_PKT_TYPE_DOWNLINK_CLASS_C	inc/jitqueue.h	/^	JIT_PKT_TYPE_DOWNLINK_CLASS_C,$/;"	e	enum:jit_pkt_type_e
JIT_QUEUE_MAX	inc/jitqueue.h	32;"	d
JSONArray	inc/parson.h	/^		JSONArray = 5,$/;"	e	enum:json_value_type
JSONBoolean	inc/parson.h	/^		JSONBoolean = 6$/;"	e	enum:json_value_type
JSONError	inc/parson.h	/^		JSONError = -1,$/;"	e	enum:json_value_type
JSONFailure	inc/parson.h	/^		JSONFailure = -1$/;"	e	enum:json_result_t
JSONNull	inc/parson.h	/^		JSONNull = 1,$/;"	e	enum:json_value_type
JSONNumber	inc/parson.h	/^		JSONNumber = 3,$/;"	e	enum:json_value_type
JSONObject	inc/parson.h	/^		JSONObject = 4,$/;"	e	enum:json_value_type
JSONString	inc/parson.h	/^		JSONString = 2,$/;"	e	enum:json_value_type
JSONSuccess	inc/parson.h	/^		JSONSuccess = 0,$/;"	e	enum:json_result_t
JSON_Array	inc/parson.h	/^	typedef struct json_array_t JSON_Array;$/;"	t	typeref:struct:json_array_t
JSON_Free_Function	inc/parson.h	/^	typedef void (*JSON_Free_Function) (void *);$/;"	t
JSON_Malloc_Function	inc/parson.h	/^	typedef void *(*JSON_Malloc_Function) (size_t);$/;"	t
JSON_Object	inc/parson.h	/^	typedef struct json_object_t JSON_Object;$/;"	t	typeref:struct:json_object_t
JSON_Status	inc/parson.h	/^	typedef int JSON_Status;$/;"	t
JSON_Value	inc/parson.h	/^	typedef struct json_value_t JSON_Value;$/;"	t	typeref:struct:json_value_t
JSON_Value_Type	inc/parson.h	/^	typedef int JSON_Value_Type;$/;"	t
JSON_Value_Value	src/parson.c	/^} JSON_Value_Value;$/;"	t	typeref:union:json_value_value	file:
LDFLAGS	Makefile	/^LDFLAGS ?=$/;"	m
LGW_INC	Makefile	/^LGW_INC =$/;"	m
LGW_PATH	Makefile	/^LGW_PATH ?= ..\/libloragw$/;"	m
LIBS	Makefile	/^LIBS:=$/;"	m
LOGGER	inc/trace.h	44;"	d
MAX	src/parson.c	45;"	d	file:
MAX_NESTING	src/parson.c	40;"	d	file:
MAX_SERVERS	inc/dragino_gw_fwd.h	24;"	d
MAX_SERVERS	src/gwtraf_transport.c	78;"	d	file:
MAX_SERVERS	src/semtech_transport.c	78;"	d	file:
MAX_SERVERS	src/stats.c	46;"	d	file:
MIN_FSK_PREAMB	inc/dragino_gw_fwd.h	29;"	d
MIN_FSK_PREAMB	src/ttn_transport.c	48;"	d	file:
MIN_LORA_PREAMB	inc/dragino_gw_fwd.h	27;"	d
MIN_LORA_PREAMB	src/ttn_transport.c	46;"	d	file:
MQTT_PATH	Makefile	/^MQTT_PATH ?= ..\/libmqtt$/;"	m
MSG	inc/trace.h	35;"	d
MSG_DEBUG	inc/trace.h	37;"	d
NB_PKT_MAX	inc/dragino_gw_fwd.h	25;"	d
NODE_CALL_SECS	inc/ghost.h	37;"	d
OBJDIR	Makefile	/^OBJDIR = obj$/;"	m
OBJECT_MAX_CAPACITY	src/parson.c	39;"	d	file:
PKT_FWD	inc/stats.h	/^	PKT_FWD$/;"	e	enum:stats_up
PKT_PULL_ACK	src/dragino_gw_fwd.c	112;"	d	file:
PKT_PULL_ACK	src/gwtraf_transport.c	89;"	d	file:
PKT_PULL_ACK	src/semtech_transport.c	89;"	d	file:
PKT_PULL_DATA	src/dragino_gw_fwd.c	110;"	d	file:
PKT_PULL_DATA	src/gwtraf_transport.c	87;"	d	file:
PKT_PULL_DATA	src/semtech_transport.c	87;"	d	file:
PKT_PULL_RESP	src/dragino_gw_fwd.c	111;"	d	file:
PKT_PULL_RESP	src/gwtraf_transport.c	88;"	d	file:
PKT_PULL_RESP	src/semtech_transport.c	88;"	d	file:
PKT_PUSH_ACK	src/dragino_gw_fwd.c	109;"	d	file:
PKT_PUSH_ACK	src/gwtraf_transport.c	86;"	d	file:
PKT_PUSH_ACK	src/semtech_transport.c	86;"	d	file:
PKT_PUSH_DATA	src/dragino_gw_fwd.c	108;"	d	file:
PKT_PUSH_DATA	src/gwtraf_transport.c	85;"	d	file:
PKT_PUSH_DATA	src/semtech_transport.c	85;"	d	file:
PKT_TX_ACK	src/dragino_gw_fwd.c	113;"	d	file:
PKT_TX_ACK	src/gwtraf_transport.c	90;"	d	file:
PKT_TX_ACK	src/semtech_transport.c	90;"	d	file:
PROTOCOL_VERSION	src/dragino_gw_fwd.c	103;"	d	file:
PROTOCOL_VERSION	src/ghost.c	45;"	d	file:
PROTOCOL_VERSION	src/gwtraf_transport.c	79;"	d	file:
PROTOCOL_VERSION	src/semtech_transport.c	79;"	d	file:
PULL_TIMEOUT_MS	src/dragino_gw_fwd.c	98;"	d	file:
PULL_TIMEOUT_MS	src/gwtraf_transport.c	83;"	d	file:
PULL_TIMEOUT_MS	src/semtech_transport.c	83;"	d	file:
PUSH_TIMEOUT_MS	src/dragino_gw_fwd.c	97;"	d	file:
PUSH_TIMEOUT_MS	src/gwtraf_transport.c	82;"	d	file:
PUSH_TIMEOUT_MS	src/semtech_transport.c	82;"	d	file:
Queue	inc/transport.h	/^typedef struct _queue Queue;$/;"	t	typeref:struct:_queue
RELEASE_VERSION	Makefile	/^RELEASE_VERSION := $(shell cat VERSION)$/;"	m
RX_BAD	inc/stats.h	/^	RX_BAD,$/;"	e	enum:stats_up
RX_NOCRC	inc/stats.h	/^	RX_NOCRC,$/;"	e	enum:stats_up
RX_OK	inc/stats.h	/^	RX_OK,$/;"	e	enum:stats_up
RX_RCV	inc/stats.h	/^	RX_RCV,$/;"	e	enum:stats_up
SIZEOF_TOKEN	src/parson.c	42;"	d	file:
SKIP_CHAR	src/parson.c	43;"	d	file:
SKIP_WHITESPACES	src/parson.c	44;"	d	file:
STARTING_CAPACITY	src/parson.c	37;"	d	file:
STATUS_SIZE	src/dragino_gw_fwd.c	115;"	d	file:
STATUS_SIZE	src/gwtraf_transport.c	92;"	d	file:
STATUS_SIZE	src/semtech_transport.c	92;"	d	file:
STATUS_SIZE	src/stats.c	48;"	d	file:
STD_FSK_PREAMB	inc/dragino_gw_fwd.h	30;"	d
STD_FSK_PREAMB	src/ttn_transport.c	49;"	d	file:
STD_LORA_PREAMB	inc/dragino_gw_fwd.h	28;"	d
STD_LORA_PREAMB	src/ttn_transport.c	47;"	d	file:
STR	src/dragino_gw_fwd.c	81;"	d	file:
STR	src/gwtraf_transport.c	74;"	d	file:
STR	src/semtech_transport.c	74;"	d	file:
STRINGIFY	src/dragino_gw_fwd.c	80;"	d	file:
STRINGIFY	src/gwtraf_transport.c	73;"	d	file:
STRINGIFY	src/semtech_transport.c	73;"	d	file:
Server	inc/transport.h	/^typedef struct _server Server;$/;"	t	typeref:struct:_server
TDARG	inc/transport.h	/^typedef struct _tdarg TDARG;$/;"	t	typeref:struct:_tdarg
TTN_INC	Makefile	/^TTN_INC := -I$(TTN_PATH) $/;"	m
TTN_PATH	Makefile	/^TTN_PATH ?= ..\/libttn$/;"	m
TX_BUFF_SIZE	src/dragino_gw_fwd.c	116;"	d	file:
TX_BUFF_SIZE	src/gwtraf_transport.c	93;"	d	file:
TX_BUFF_SIZE	src/semtech_transport.c	93;"	d	file:
TX_BUFF_SIZE	src/stats.c	49;"	d	file:
TX_FAIL	inc/stats.h	/^	TX_FAIL,$/;"	e	enum:stats_down
TX_JIT_DELAY	src/jitqueue.c	39;"	d	file:
TX_MARGIN_DELAY	src/jitqueue.c	37;"	d	file:
TX_MAX_ADVANCE_DELAY	src/jitqueue.c	40;"	d	file:
TX_OK	inc/stats.h	/^	TX_OK,$/;"	e	enum:stats_down
TX_REJ_COLL_BEACON	inc/stats.h	/^	TX_REJ_COLL_BEACON,$/;"	e	enum:stats_down
TX_REJ_COLL_PACKET	inc/stats.h	/^	TX_REJ_COLL_PACKET,$/;"	e	enum:stats_down
TX_REJ_TOO_EARLY	inc/stats.h	/^	TX_REJ_TOO_EARLY,$/;"	e	enum:stats_down
TX_REJ_TOO_LATE	inc/stats.h	/^	TX_REJ_TOO_LATE,$/;"	e	enum:stats_down
TX_REQUESTED	inc/stats.h	/^	TX_REQUESTED,$/;"	e	enum:stats_down
TX_START_DELAY	src/jitqueue.c	35;"	d	file:
VERSION_STRING	src/dragino_gw_fwd.c	88;"	d	file:
VFLAG	Makefile	/^VFLAG := -D VERSION_STRING="\\"$(RELEASE_VERSION)\\""$/;"	m
XERR_FILT_COEF	src/dragino_gw_fwd.c	106;"	d	file:
XERR_INIT_AVG	src/dragino_gw_fwd.c	105;"	d	file:
_BASE64_H	inc/base64.h	17;"	d
_CRT_SECURE_NO_WARNINGS	src/parson.c	25;"	d	file:
_GHOST_H_	inc/ghost.h	12;"	d
_GNU_SOURCE	src/jitqueue.c	19;"	d	file:
_GWTRAF_PROTO_H	inc/gwtraf_transport.h	9;"	d
_LORA_PKTFWD_JIT_H	inc/jitqueue.h	17;"	d
_LORA_PKTFWD_STATS_H	inc/stats.h	8;"	d
_LORA_PKTFWD_TIMERSYNC_H	inc/timersync.h	17;"	d
_LORA_PKTFWD_TRACE_H	inc/trace.h	17;"	d
_MP_PKT_FWD_H_	inc/dragino_gw_fwd.h	9;"	d
_SEMTECH_PROTO_H	inc/semtech_transport.h	9;"	d
_TRANSPORT_H	inc/transport.h	9;"	d
_TTN_PROTO_H	inc/ttn_transport.h	9;"	d
_XOPEN_SOURCE	src/dragino_gw_fwd.c	28;"	d	file:
_XOPEN_SOURCE	src/dragino_gw_fwd.c	30;"	d	file:
_XOPEN_SOURCE	src/ghost.c	14;"	d	file:
_XOPEN_SOURCE	src/ghost.c	16;"	d	file:
_XOPEN_SOURCE	src/gwtraf_transport.c	26;"	d	file:
_XOPEN_SOURCE	src/gwtraf_transport.c	28;"	d	file:
_XOPEN_SOURCE	src/semtech_transport.c	26;"	d	file:
_XOPEN_SOURCE	src/semtech_transport.c	28;"	d	file:
__compar_d_fn_t	src/jitqueue.c	/^typedef int (*__compar_d_fn_t) (const void *, const void *, void *);$/;"	t	file:
_queue	inc/transport.h	/^struct _queue {$/;"	s
_server	inc/transport.h	/^struct _server {$/;"	s
_tdarg	inc/transport.h	/^struct _tdarg {$/;"	s
addr	inc/transport.h	/^	char addr[64];				\/\/ server address$/;"	m	struct:_server
antenna_gain	src/dragino_gw_fwd.c	/^int8_t antenna_gain = 0;$/;"	v
append_indent	src/parson.c	/^static int append_indent(char *buf, int level) {$/;"	f	file:
append_string	src/parson.c	/^static int append_string(char *buf, const char *string) {$/;"	f	file:
array	src/parson.c	/^	JSON_Array *array;$/;"	m	union:json_value_value	file:
autoquit_threshold	src/dragino_gw_fwd.c	/^uint32_t autoquit_threshold = 0;	\/* enable auto-quit after a number of non-acknowledged PULL_DATA (0 = disabled) *\/$/;"	v
b64_to_bin	src/base64.c	/^int b64_to_bin(const char *in, int size, uint8_t * out, int max_len) {$/;"	f
b64_to_bin_nopad	src/base64.c	/^int b64_to_bin_nopad(const char *in, int size, uint8_t * out, int max_len) {$/;"	f
beacon_enabled	src/dragino_gw_fwd.c	/^bool beacon_enabled = false;	\/* controls the activation of the time beacon.      *\/$/;"	v
beacon_freq_hz	src/dragino_gw_fwd.c	/^uint32_t beacon_freq_hz = 0;	\/* TX beacon frequency, in Hz *\/$/;"	v
beacon_period	src/dragino_gw_fwd.c	/^uint32_t beacon_period = 0;		\/* set beaconing period, must be a sub-multiple of 86400, the number of seconds in a day *\/$/;"	v
bin_to_b64	src/base64.c	/^int bin_to_b64(const uint8_t * in, int size, char *out, int max_len) {$/;"	f
bin_to_b64_nopad	src/base64.c	/^int bin_to_b64_nopad(const uint8_t * in, int size, char *out, int max_len) {$/;"	f
boolean	src/parson.c	/^	int boolean;$/;"	m	union:json_value_value	file:
buffRX	src/ghost.c	/^static uint8_t buffRX[GHST_RX_BUFFSIZE * GHST_NM_RCV];	\/* circular buffer for receiving packets *\/$/;"	v	file:
capacity	src/parson.c	/^	size_t capacity;$/;"	m	struct:json_array_t	file:
capacity	src/parson.c	/^	size_t capacity;$/;"	m	struct:json_object_t	file:
cb_ghost	src/ghost.c	/^static pthread_mutex_t cb_ghost = PTHREAD_MUTEX_INITIALIZER;	\/* control access to the ghoststream measurements *\/$/;"	v	file:
char_to_code	src/base64.c	/^uint8_t char_to_code(char x) {$/;"	f
code_62	src/base64.c	/^static char code_62 = '+';		\/* RFC 1421 standard character for code 62 *\/$/;"	v	file:
code_63	src/base64.c	/^static char code_63 = '\/';		\/* RFC 1421 standard character for code 63 *\/$/;"	v	file:
code_pad	src/base64.c	/^static char code_pad = '=';		\/* RFC 1421 padding character if padding *\/$/;"	v	file:
code_to_char	src/base64.c	/^char code_to_char(uint8_t x) {$/;"	f
compare	src/jitqueue.c	/^int compare(void *arg, const void *a, const void *b)$/;"	f
connecting	inc/transport.h	/^	bool connecting;			\/\/ Connection setup in progress$/;"	m	struct:_server
contact	inc/transport.h	/^	time_t contact;				\/\/ time of last contact$/;"	m	struct:_server
count	src/parson.c	/^	size_t count;$/;"	m	struct:json_array_t	file:
count	src/parson.c	/^	size_t count;$/;"	m	struct:json_object_t	file:
crc_ccit	src/semtech_transport.c	/^static uint16_t crc_ccit(const uint8_t * data, unsigned size) {$/;"	f	file:
critical	inc/transport.h	/^	bool critical;				\/\/ Transport critical? Should connect at startup?$/;"	m	struct:_server
data	inc/transport.h	/^	struct lgw_pkt_rx_s data[NB_PKT_MAX];$/;"	m	struct:_queue	typeref:struct:_queue::lgw_pkt_rx_s
debugLog	src/ttn_transport.c	/^FILE *debugLog = NULL;$/;"	v
debug_mask	src/dragino_gw_fwd.c	/^int debug_mask;$/;"	v
description	src/dragino_gw_fwd.c	/^char description[64] = "";		\/* used for free form description *\/$/;"	v
difftimespec	src/dragino_gw_fwd.c	/^double difftimespec(struct timespec end, struct timespec beginning) {$/;"	f
downlink	src/stats.c	/^struct statistics_downlink downlink;$/;"	v	typeref:struct:statistics_downlink
downstream	inc/transport.h	/^	bool downstream;			\/\/ downstream enabled$/;"	m	struct:_server
downstream_enabled	src/dragino_gw_fwd.c	/^bool downstream_enabled = true;	\/* controls the data flow from server to end-node         *\/$/;"	v
eflt	src/ghost.c	/^static float eflt(uint8_t * p, uint8_t i) {$/;"	f	file:
email	src/dragino_gw_fwd.c	/^char email[40] = "";			\/* used for contact email *\/$/;"	v
enabled	inc/transport.h	/^	bool enabled;				\/\/ server enabled$/;"	m	struct:_server
exit_sig	src/dragino_gw_fwd.c	/^volatile bool exit_sig = false;	\/* 1 -> application terminates cleanly (shut down hardware, close open files, etc) *\/$/;"	v
f	src/ghost.c	/^	float f;$/;"	m	union:__anon1	file:
flush_enabled	src/dragino_gw_fwd.c	/^bool flush_enabled = false;		\/* flush output after statistics                    *\/$/;"	v
flush_line	src/dragino_gw_fwd.c	/^bool flush_line = false;		\/* flush output after every line                    *\/$/;"	v
free	src/parson.c	48;"	d	file:
frequency_plan	src/dragino_gw_fwd.c	/^char *frequency_plan = NULL;$/;"	v
fwd_error_pkt	src/dragino_gw_fwd.c	/^bool fwd_error_pkt = false;		\/* packets with PAYLOAD CRC ERROR are NOT forwarded *\/$/;"	v
fwd_nocrc_pkt	src/dragino_gw_fwd.c	/^bool fwd_nocrc_pkt = false;		\/* packets with NO PAYLOAD CRC are NOT forwarded *\/$/;"	v
fwd_valid_pkt	src/dragino_gw_fwd.c	/^bool fwd_valid_pkt = true;		\/* packets with PAYLOAD CRC OK are forwarded *\/$/;"	v
gateway_id	src/dragino_gw_fwd.c	/^char gateway_id[20] = "";		\/* string form of gateway mac address *\/$/;"	v
gateway_id	src/ghost.c	/^static char gateway_id[16] = "";	\/* string form of gateway mac address *\/$/;"	v	file:
get_concentrator_time	src/timersync.c	/^int get_concentrator_time(struct timeval *concent_time,$/;"	f
get_quoted_string	src/parson.c	/^static char *get_quoted_string(const char **string) {$/;"	f	file:
ghost_addr	src/dragino_gw_fwd.c	/^static char ghost_addr[64] = "127.0.0.1";	\/* address of the server (host name or IPv4\/IPv6) *\/$/;"	v	file:
ghost_get	src/ghost.c	/^int ghost_get(int max_pkt, struct lgw_pkt_rx_s *pkt_data) {	\/* Calculate the number of available packets *\/$/;"	f
ghost_port	src/dragino_gw_fwd.c	/^static char ghost_port[8] = "1914";	\/* port to listen on *\/$/;"	v	file:
ghost_put	src/ghost.c	/^int ghost_put() {				\/\/TODO: Implement this method.$/;"	f
ghost_run	src/ghost.c	/^volatile bool ghost_run = false;	\/* false -> ghost thread terminates cleanly *\/$/;"	v
ghost_start	src/ghost.c	/^void ghost_start(const char *ghost_addr, const char *ghost_port,$/;"	f
ghost_stop	src/ghost.c	/^void ghost_stop(void) {$/;"	f
ghost_timeout	src/ghost.c	/^struct timeval ghost_timeout = { 0, (200 * 1000) };	\/* non critical for throughput *\/$/;"	v	typeref:struct:timeval
ghoststream_enabled	src/dragino_gw_fwd.c	/^static bool ghoststream_enabled = false;	\/* controls the data flow from ghost-node to server       *\/$/;"	v	file:
ghst_bgn	src/ghost.c	/^static uint8_t ghst_bgn;		\/* begin of circular packet buffer *\/$/;"	v	file:
ghst_end	src/ghost.c	/^static uint8_t ghst_end;		\/* end of circular packet buffer  *\/$/;"	v	file:
gps_active	src/dragino_gw_fwd.c	/^bool gps_active = false;		\/* is GPS present and working on the board? *\/$/;"	v
gps_coord_valid	src/dragino_gw_fwd.c	/^bool gps_coord_valid;			\/* could we get valid GPS coordinates? *\/$/;"	v
gps_enabled	src/dragino_gw_fwd.c	/^bool gps_enabled = false;		\/* controls the use of the GPS                      *\/$/;"	v
gps_fake_enable	src/dragino_gw_fwd.c	/^bool gps_fake_enable;			\/* fake coordinates override real coordinates *\/$/;"	v
gps_process_coords	src/dragino_gw_fwd.c	/^static void gps_process_coords(void) {$/;"	f	file:
gps_process_sync	src/dragino_gw_fwd.c	/^static void gps_process_sync(void) {$/;"	f	file:
gps_ref_valid	src/dragino_gw_fwd.c	/^bool gps_ref_valid;				\/* is GPS reference acceptable (ie. not too old) *\/$/;"	v
gps_tty_fd	src/dragino_gw_fwd.c	/^static int gps_tty_fd = -1;		\/* file descriptor of the GPS TTY port *\/$/;"	v	file:
gps_tty_path	src/dragino_gw_fwd.c	/^static char gps_tty_path[64] = "\\0";	\/* path of the TTY port GPS is connected on *\/$/;"	v	file:
gw_id	inc/transport.h	/^	char gw_id[64];				\/\/ gateway ID for TTN$/;"	m	struct:_server
gw_key	inc/transport.h	/^	char gw_key[200];			\/\/ gateway key to connect to TTN$/;"	m	struct:_server
gw_port	inc/transport.h	/^	int gw_port;				\/\/ gateway port$/;"	m	struct:_server
gwtraf	inc/transport.h	/^	gwtraf$/;"	e	enum:server_type
gwtraf_data_up	src/gwtraf_transport.c	/^void gwtraf_data_up(int idx, int nb_pkt, struct lgw_pkt_rx_s *rxpkt) {$/;"	f
gwtraf_downtraf	src/gwtraf_transport.c	/^void gwtraf_downtraf(int idx, char *json, int len) {$/;"	f
gwtraf_init	src/gwtraf_transport.c	/^void gwtraf_init(int idx) {$/;"	f
gwtraf_stop	src/gwtraf_transport.c	/^void gwtraf_stop(int idx) {$/;"	f
gwtraf_upstream	src/gwtraf_transport.c	/^void gwtraf_upstream(void *pic) {$/;"	f
idx	inc/transport.h	/^	int idx;$/;"	m	struct:_tdarg
increment_down	src/stats.c	/^void increment_down(enum stats_down type) {$/;"	f
increment_up	src/stats.c	/^void increment_up(enum stats_up type) {$/;"	f
init_socket	src/dragino_gw_fwd.c	/^static int init_socket(const char *servaddr, const char *servport, const char *rectimeout, int len) {$/;"	f	file:
isBigEndian	src/endianext.c	/^bool isBigEndian() {$/;"	f
isLittleEndian	src/endianext.c	/^bool isLittleEndian() {$/;"	f
isMiddleEndian	src/endianext.c	/^bool isMiddleEndian() {$/;"	f
is_decimal	src/parson.c	/^static int is_decimal(const char *string, size_t length) {$/;"	f	file:
is_utf16_hex	src/parson.c	/^static int is_utf16_hex(const unsigned char *s) {$/;"	f	file:
is_valid_utf8	src/parson.c	/^static int is_valid_utf8(const char *string, size_t string_len) {$/;"	f	file:
items	src/parson.c	/^	JSON_Value **items;$/;"	m	struct:json_array_t	file:
jit_collision_test	src/jitqueue.c	/^bool jit_collision_test(uint32_t p1_count_us, uint32_t p1_pre_delay,$/;"	f
jit_dequeue	src/jitqueue.c	/^enum jit_error_e jit_dequeue(struct jit_queue_s *queue, int index,$/;"	f
jit_enqueue	src/jitqueue.c	/^enum jit_error_e jit_enqueue(struct jit_queue_s *queue, struct timeval *time,$/;"	f
jit_error	src/jitqueue.c	/^char *jit_error(enum jit_error_e error) {$/;"	f
jit_error_e	inc/jitqueue.h	/^enum jit_error_e {$/;"	g
jit_node_s	inc/jitqueue.h	/^struct jit_node_s {$/;"	s
jit_peek	src/jitqueue.c	/^enum jit_error_e jit_peek(struct jit_queue_s *queue, struct timeval *time,$/;"	f
jit_pkt_type_e	inc/jitqueue.h	/^enum jit_pkt_type_e {$/;"	g
jit_print_queue	src/jitqueue.c	/^void jit_print_queue(struct jit_queue_s *queue, bool show_all, int debug_level) {$/;"	f
jit_queue	src/dragino_gw_fwd.c	/^struct jit_queue_s jit_queue;$/;"	v	typeref:struct:jit_queue_s
jit_queue_init	src/jitqueue.c	/^void jit_queue_init(struct jit_queue_s *queue) {$/;"	f
jit_queue_is_empty	src/jitqueue.c	/^bool jit_queue_is_empty(struct jit_queue_s * queue) {$/;"	f
jit_queue_is_full	src/jitqueue.c	/^bool jit_queue_is_full(struct jit_queue_s * queue) {$/;"	f
jit_queue_s	inc/jitqueue.h	/^struct jit_queue_s {$/;"	s
jit_report_queue	src/jitqueue.c	/^void jit_report_queue(struct jit_queue_s *queue) {$/;"	f
jit_sort_queue	src/jitqueue.c	/^void jit_sort_queue(struct jit_queue_s *queue) {$/;"	f
json_array	src/parson.c	/^JSON_Array *json_array(const JSON_Value * value) {$/;"	f
json_array_add	src/parson.c	/^static JSON_Status json_array_add(JSON_Array * array, JSON_Value * value) {$/;"	f	file:
json_array_append_boolean	src/parson.c	/^JSON_Status json_array_append_boolean(JSON_Array * array, int boolean) {$/;"	f
json_array_append_generic	src/parson.c	/^typedef JSON_Status(*json_array_append_generic) (JSON_Array * array, void *box,$/;"	t	file:
json_array_append_generic_boolean	src/parson.c	/^static JSON_Status json_array_append_generic_boolean(JSON_Array * array,$/;"	f	file:
json_array_append_generic_double	src/parson.c	/^static JSON_Status json_array_append_generic_double(JSON_Array * array,$/;"	f	file:
json_array_append_generic_int	src/parson.c	/^static JSON_Status json_array_append_generic_int(JSON_Array * array, void *box,$/;"	f	file:
json_array_append_generic_string	src/parson.c	/^static JSON_Status json_array_append_generic_string(JSON_Array * array,$/;"	f	file:
json_array_append_null	src/parson.c	/^JSON_Status json_array_append_null(JSON_Array * array) {$/;"	f
json_array_append_number	src/parson.c	/^JSON_Status json_array_append_number(JSON_Array * array, double number) {$/;"	f
json_array_append_string	src/parson.c	/^JSON_Status json_array_append_string(JSON_Array * array, const char *string) {$/;"	f
json_array_append_value	src/parson.c	/^JSON_Status json_array_append_value(JSON_Array * array, JSON_Value * value) {$/;"	f
json_array_clear	src/parson.c	/^JSON_Status json_array_clear(JSON_Array * array) {$/;"	f
json_array_free	src/parson.c	/^static void json_array_free(JSON_Array * array) {$/;"	f	file:
json_array_get_array	src/parson.c	/^JSON_Array *json_array_get_array(const JSON_Array * array, size_t index) {$/;"	f
json_array_get_boolean	src/parson.c	/^int json_array_get_boolean(const JSON_Array * array, size_t index) {$/;"	f
json_array_get_count	src/parson.c	/^size_t json_array_get_count(const JSON_Array * array) {$/;"	f
json_array_get_number	src/parson.c	/^double json_array_get_number(const JSON_Array * array, size_t index) {$/;"	f
json_array_get_object	src/parson.c	/^JSON_Object *json_array_get_object(const JSON_Array * array, size_t index) {$/;"	f
json_array_get_string	src/parson.c	/^const char *json_array_get_string(const JSON_Array * array, size_t index) {$/;"	f
json_array_get_value	src/parson.c	/^JSON_Value *json_array_get_value(const JSON_Array * array, size_t index) {$/;"	f
json_array_init	src/parson.c	/^static JSON_Array *json_array_init(void) {$/;"	f	file:
json_array_remove	src/parson.c	/^JSON_Status json_array_remove(JSON_Array * array, size_t ix) {$/;"	f
json_array_replace_boolean	src/parson.c	/^JSON_Status json_array_replace_boolean(JSON_Array * array, size_t i,$/;"	f
json_array_replace_null	src/parson.c	/^JSON_Status json_array_replace_null(JSON_Array * array, size_t i) {$/;"	f
json_array_replace_number	src/parson.c	/^JSON_Status json_array_replace_number(JSON_Array * array, size_t i,$/;"	f
json_array_replace_string	src/parson.c	/^JSON_Status json_array_replace_string(JSON_Array * array, size_t i,$/;"	f
json_array_replace_value	src/parson.c	/^JSON_Status json_array_replace_value(JSON_Array * array, size_t ix,$/;"	f
json_array_resize	src/parson.c	/^static JSON_Status json_array_resize(JSON_Array * array, size_t new_capacity) {$/;"	f	file:
json_array_t	src/parson.c	/^struct json_array_t {$/;"	s	file:
json_boolean	src/parson.c	/^int json_boolean(const JSON_Value * value) {$/;"	f
json_free_serialized_string	src/parson.c	/^void json_free_serialized_string(char *string) {$/;"	f
json_number	src/parson.c	/^double json_number(const JSON_Value * value) {$/;"	f
json_object	src/parson.c	/^JSON_Object *json_object(const JSON_Value * value) {$/;"	f
json_object_add	src/parson.c	/^static JSON_Status json_object_add(JSON_Object * object, const char *name,$/;"	f	file:
json_object_clear	src/parson.c	/^JSON_Status json_object_clear(JSON_Object * object) {$/;"	f
json_object_dotget_array	src/parson.c	/^JSON_Array *json_object_dotget_array(const JSON_Object * object,$/;"	f
json_object_dotget_boolean	src/parson.c	/^int json_object_dotget_boolean(const JSON_Object * object, const char *name) {$/;"	f
json_object_dotget_number	src/parson.c	/^double json_object_dotget_number(const JSON_Object * object, const char *name) {$/;"	f
json_object_dotget_object	src/parson.c	/^JSON_Object *json_object_dotget_object(const JSON_Object * object,$/;"	f
json_object_dotget_string	src/parson.c	/^const char *json_object_dotget_string(const JSON_Object * object,$/;"	f
json_object_dotget_value	src/parson.c	/^JSON_Value *json_object_dotget_value(const JSON_Object * object,$/;"	f
json_object_dothas_value	src/parson.c	/^int json_object_dothas_value(const JSON_Object * object, const char *name) {$/;"	f
json_object_dothas_value_of_type	src/parson.c	/^int json_object_dothas_value_of_type(const JSON_Object * object,$/;"	f
json_object_dotremove	src/parson.c	/^JSON_Status json_object_dotremove(JSON_Object * object, const char *name) {$/;"	f
json_object_dotset_boolean	src/parson.c	/^JSON_Status json_object_dotset_boolean(JSON_Object * object, const char *name,$/;"	f
json_object_dotset_boolean_array	src/parson.c	/^JSON_Status json_object_dotset_boolean_array(JSON_Object * object,$/;"	f
json_object_dotset_double_array	src/parson.c	/^JSON_Status json_object_dotset_double_array(JSON_Object * object,$/;"	f
json_object_dotset_int_array	src/parson.c	/^JSON_Status json_object_dotset_int_array(JSON_Object * object, const char *name,$/;"	f
json_object_dotset_null	src/parson.c	/^JSON_Status json_object_dotset_null(JSON_Object * object, const char *name) {$/;"	f
json_object_dotset_number	src/parson.c	/^JSON_Status json_object_dotset_number(JSON_Object * object, const char *name,$/;"	f
json_object_dotset_string	src/parson.c	/^JSON_Status json_object_dotset_string(JSON_Object * object, const char *name,$/;"	f
json_object_dotset_string_array	src/parson.c	/^JSON_Status json_object_dotset_string_array(JSON_Object * object,$/;"	f
json_object_dotset_value	src/parson.c	/^JSON_Status json_object_dotset_value(JSON_Object * object, const char *name,$/;"	f
json_object_free	src/parson.c	/^static void json_object_free(JSON_Object * object) {$/;"	f	file:
json_object_generic_set_value	src/parson.c	/^typedef JSON_Status(*json_object_generic_set_value) (JSON_Object * object,$/;"	t	file:
json_object_get_array	src/parson.c	/^JSON_Array *json_object_get_array(const JSON_Object * object, const char *name) {$/;"	f
json_object_get_boolean	src/parson.c	/^int json_object_get_boolean(const JSON_Object * object, const char *name) {$/;"	f
json_object_get_count	src/parson.c	/^size_t json_object_get_count(const JSON_Object * object) {$/;"	f
json_object_get_name	src/parson.c	/^const char *json_object_get_name(const JSON_Object * object, size_t index) {$/;"	f
json_object_get_number	src/parson.c	/^double json_object_get_number(const JSON_Object * object, const char *name) {$/;"	f
json_object_get_object	src/parson.c	/^JSON_Object *json_object_get_object(const JSON_Object * object,$/;"	f
json_object_get_string	src/parson.c	/^const char *json_object_get_string(const JSON_Object * object, const char *name) {$/;"	f
json_object_get_value	src/parson.c	/^JSON_Value *json_object_get_value(const JSON_Object * object, const char *name) {$/;"	f
json_object_get_value_at	src/parson.c	/^JSON_Value *json_object_get_value_at(const JSON_Object * object, size_t index) {$/;"	f
json_object_has_value	src/parson.c	/^int json_object_has_value(const JSON_Object * object, const char *name) {$/;"	f
json_object_has_value_of_type	src/parson.c	/^int json_object_has_value_of_type(const JSON_Object * object, const char *name,$/;"	f
json_object_init	src/parson.c	/^static JSON_Object *json_object_init(void) {$/;"	f	file:
json_object_nget_value	src/parson.c	/^static JSON_Value *json_object_nget_value(const JSON_Object * object,$/;"	f	file:
json_object_remove	src/parson.c	/^JSON_Status json_object_remove(JSON_Object * object, const char *name) {$/;"	f
json_object_resize	src/parson.c	/^static JSON_Status json_object_resize(JSON_Object * object, size_t new_capacity) {$/;"	f	file:
json_object_set_boolean	src/parson.c	/^JSON_Status json_object_set_boolean(JSON_Object * object, const char *name,$/;"	f
json_object_set_boolean_array	src/parson.c	/^JSON_Status json_object_set_boolean_array(JSON_Object * object,$/;"	f
json_object_set_double_array	src/parson.c	/^JSON_Status json_object_set_double_array(JSON_Object * object, const char *name,$/;"	f
json_object_set_int_array	src/parson.c	/^JSON_Status json_object_set_int_array(JSON_Object * object, const char *name,$/;"	f
json_object_set_null	src/parson.c	/^JSON_Status json_object_set_null(JSON_Object * object, const char *name) {$/;"	f
json_object_set_number	src/parson.c	/^JSON_Status json_object_set_number(JSON_Object * object, const char *name,$/;"	f
json_object_set_number_generic	src/parson.c	/^static JSON_Status json_object_set_number_generic(JSON_Object * object,$/;"	f	file:
json_object_set_string	src/parson.c	/^JSON_Status json_object_set_string(JSON_Object * object, const char *name,$/;"	f
json_object_set_string_array	src/parson.c	/^JSON_Status json_object_set_string_array(JSON_Object * object, const char *name,$/;"	f
json_object_set_value	src/parson.c	/^JSON_Status json_object_set_value(JSON_Object * object, const char *name,$/;"	f
json_object_t	src/parson.c	/^struct json_object_t {$/;"	s	file:
json_parse_file	src/parson.c	/^JSON_Value *json_parse_file(const char *filename) {$/;"	f
json_parse_file_with_comments	src/parson.c	/^JSON_Value *json_parse_file_with_comments(const char *filename) {$/;"	f
json_parse_string	src/parson.c	/^JSON_Value *json_parse_string(const char *string) {$/;"	f
json_parse_string_with_comments	src/parson.c	/^JSON_Value *json_parse_string_with_comments(const char *string) {$/;"	f
json_result_t	inc/parson.h	/^	enum json_result_t {$/;"	g
json_serialization_size	src/parson.c	/^size_t json_serialization_size(const JSON_Value * value) {$/;"	f
json_serialization_size_pretty	src/parson.c	/^size_t json_serialization_size_pretty(const JSON_Value * value) {$/;"	f
json_serialize_string	src/parson.c	/^static int json_serialize_string(const char *string, char *buf) {$/;"	f	file:
json_serialize_to_buffer	src/parson.c	/^JSON_Status json_serialize_to_buffer(const JSON_Value * value, char *buf,$/;"	f
json_serialize_to_buffer_pretty	src/parson.c	/^JSON_Status json_serialize_to_buffer_pretty(const JSON_Value * value, char *buf,$/;"	f
json_serialize_to_buffer_r	src/parson.c	/^static int json_serialize_to_buffer_r(const JSON_Value * value, char *buf,$/;"	f	file:
json_serialize_to_file	src/parson.c	/^JSON_Status json_serialize_to_file(const JSON_Value * value,$/;"	f
json_serialize_to_file_pretty	src/parson.c	/^JSON_Status json_serialize_to_file_pretty(const JSON_Value * value,$/;"	f
json_serialize_to_string	src/parson.c	/^char *json_serialize_to_string(const JSON_Value * value) {$/;"	f
json_serialize_to_string_pretty	src/parson.c	/^char *json_serialize_to_string_pretty(const JSON_Value * value) {$/;"	f
json_set_allocation_functions	src/parson.c	/^void json_set_allocation_functions(JSON_Malloc_Function malloc_fun,$/;"	f
json_string	src/parson.c	/^const char *json_string(const JSON_Value * value) {$/;"	f
json_type	src/parson.c	/^JSON_Value_Type json_type(const JSON_Value * value) {$/;"	f
json_validate	src/parson.c	/^JSON_Status json_validate(const JSON_Value * schema, const JSON_Value * value) {$/;"	f
json_value_deep_copy	src/parson.c	/^JSON_Value *json_value_deep_copy(const JSON_Value * value) {$/;"	f
json_value_equals	src/parson.c	/^JSON_Status json_value_equals(const JSON_Value * a, const JSON_Value * b) {$/;"	f
json_value_free	src/parson.c	/^void json_value_free(JSON_Value * value) {$/;"	f
json_value_get_array	src/parson.c	/^JSON_Array *json_value_get_array(const JSON_Value * value) {$/;"	f
json_value_get_boolean	src/parson.c	/^int json_value_get_boolean(const JSON_Value * value) {$/;"	f
json_value_get_number	src/parson.c	/^double json_value_get_number(const JSON_Value * value) {$/;"	f
json_value_get_object	src/parson.c	/^JSON_Object *json_value_get_object(const JSON_Value * value) {$/;"	f
json_value_get_string	src/parson.c	/^const char *json_value_get_string(const JSON_Value * value) {$/;"	f
json_value_get_type	src/parson.c	/^JSON_Value_Type json_value_get_type(const JSON_Value * value) {$/;"	f
json_value_init_array	src/parson.c	/^JSON_Value *json_value_init_array(void) {$/;"	f
json_value_init_boolean	src/parson.c	/^JSON_Value *json_value_init_boolean(int boolean) {$/;"	f
json_value_init_null	src/parson.c	/^JSON_Value *json_value_init_null(void) {$/;"	f
json_value_init_number	src/parson.c	/^JSON_Value *json_value_init_number(double number) {$/;"	f
json_value_init_object	src/parson.c	/^JSON_Value *json_value_init_object(void) {$/;"	f
json_value_init_string	src/parson.c	/^JSON_Value *json_value_init_string(const char *string) {$/;"	f
json_value_init_string_no_copy	src/parson.c	/^static JSON_Value *json_value_init_string_no_copy(char *string) {$/;"	f	file:
json_value_t	src/parson.c	/^struct json_value_t {$/;"	s	file:
json_value_type	inc/parson.h	/^	enum json_value_type {$/;"	g
json_value_value	src/parson.c	/^typedef union json_value_value {$/;"	u	file:
keepalive_time	src/dragino_gw_fwd.c	/^int keepalive_time = DEFAULT_KEEPALIVE;	\/* send a PULL_DATA request every X seconds, negative = disabled *\/$/;"	v
last_loop	src/dragino_gw_fwd.c	/^time_t last_loop;$/;"	v
lgwm	src/dragino_gw_fwd.c	/^uint64_t lgwm = 0;				\/* Lora gateway MAC address *\/$/;"	v
live	inc/transport.h	/^	bool live;					\/\/ Server is life?$/;"	m	struct:_server
logfile_path	src/dragino_gw_fwd.c	/^char *logfile_path = NULL;$/;"	v
logger_enabled	src/dragino_gw_fwd.c	/^bool logger_enabled = false;	\/* controls the activation of more logging          *\/$/;"	v
logmessage	src/dragino_gw_fwd.c	/^void logmessage(const char *fmt, ...) {$/;"	f
long_options	src/dragino_gw_fwd.c	/^static struct option long_options[] = {$/;"	v	typeref:struct:option	file:
main	src/dragino_gw_fwd.c	/^int main(int argc, char *argv[]) {$/;"	f
malloc	src/parson.c	47;"	d	file:
max_stall	inc/transport.h	/^	int max_stall;				\/\/ max number of missed responses$/;"	m	struct:_server
meas_dw_ack_rcv	src/dragino_gw_fwd.c	/^uint32_t meas_dw_ack_rcv[MAX_SERVERS] = { 0 };	\/* number of PULL requests acknowledged for downstream traffic *\/$/;"	v
meas_dw_dgram_acp	src/dragino_gw_fwd.c	/^uint32_t meas_dw_dgram_acp[MAX_SERVERS] = { 0 };	\/* response datagrams that are accepted for transmission *\/$/;"	v
meas_dw_dgram_rcv	src/dragino_gw_fwd.c	/^uint32_t meas_dw_dgram_rcv[MAX_SERVERS] = { 0 };	\/* count PULL response datagrams received for downstream traffic *\/$/;"	v
meas_dw_network_byte	src/dragino_gw_fwd.c	/^uint32_t meas_dw_network_byte = 0;	\/* sum of UDP bytes sent for upstream traffic *\/$/;"	v
meas_dw_payload_byte	src/dragino_gw_fwd.c	/^uint32_t meas_dw_payload_byte = 0;	\/* sum of radio payload bytes sent for upstream traffic *\/$/;"	v
meas_dw_pull_sent	src/dragino_gw_fwd.c	/^uint32_t meas_dw_pull_sent[MAX_SERVERS] = { 0 };	\/* number of PULL requests sent for downstream traffic *\/$/;"	v
meas_gps_coord	src/dragino_gw_fwd.c	/^struct coord_s meas_gps_coord;	\/* GPS position of the gateway *\/$/;"	v	typeref:struct:coord_s
meas_gps_err	src/dragino_gw_fwd.c	/^struct coord_s meas_gps_err;	\/* GPS position of the gateway *\/$/;"	v	typeref:struct:coord_s
meas_nb_beacon_queued	inc/stats.h	/^	uint32_t meas_nb_beacon_queued;$/;"	m	struct:statistics_downlink
meas_nb_beacon_rejected	inc/stats.h	/^	uint32_t meas_nb_beacon_rejected;$/;"	m	struct:statistics_downlink
meas_nb_beacon_sent	inc/stats.h	/^	uint32_t meas_nb_beacon_sent;$/;"	m	struct:statistics_downlink
meas_nb_rx_bad	inc/stats.h	/^	uint32_t meas_nb_rx_bad;$/;"	m	struct:statistics_uplink
meas_nb_rx_nocrc	inc/stats.h	/^	uint32_t meas_nb_rx_nocrc;$/;"	m	struct:statistics_uplink
meas_nb_rx_ok	inc/stats.h	/^	uint32_t meas_nb_rx_ok;$/;"	m	struct:statistics_uplink
meas_nb_rx_rcv	inc/stats.h	/^	uint32_t meas_nb_rx_rcv;$/;"	m	struct:statistics_uplink
meas_nb_tx_fail	inc/stats.h	/^	uint32_t meas_nb_tx_fail;$/;"	m	struct:statistics_downlink
meas_nb_tx_ok	inc/stats.h	/^	uint32_t meas_nb_tx_ok;$/;"	m	struct:statistics_downlink
meas_nb_tx_rejected_collision_beacon	inc/stats.h	/^	uint32_t meas_nb_tx_rejected_collision_beacon;$/;"	m	struct:statistics_downlink
meas_nb_tx_rejected_collision_packet	inc/stats.h	/^	uint32_t meas_nb_tx_rejected_collision_packet;$/;"	m	struct:statistics_downlink
meas_nb_tx_rejected_too_early	inc/stats.h	/^	uint32_t meas_nb_tx_rejected_too_early;$/;"	m	struct:statistics_downlink
meas_nb_tx_rejected_too_late	inc/stats.h	/^	uint32_t meas_nb_tx_rejected_too_late;$/;"	m	struct:statistics_downlink
meas_nb_tx_requested	inc/stats.h	/^	uint32_t meas_nb_tx_requested;$/;"	m	struct:statistics_downlink
meas_up_ack_rcv	src/dragino_gw_fwd.c	/^uint32_t meas_up_ack_rcv[MAX_SERVERS] = { 0 };	\/* number of datagrams acknowledged for upstream traffic *\/$/;"	v
meas_up_dgram_sent	src/dragino_gw_fwd.c	/^uint32_t meas_up_dgram_sent[MAX_SERVERS] = { 0 };	\/* number of datagrams sent for upstream traffic *\/$/;"	v
meas_up_network_byte	src/dragino_gw_fwd.c	/^uint32_t meas_up_network_byte = 0;	\/* sum of UDP bytes sent for upstream traffic *\/$/;"	v
meas_up_payload_byte	src/dragino_gw_fwd.c	/^uint32_t meas_up_payload_byte = 0;	\/* sum of radio payload bytes sent for upstream traffic *\/$/;"	v
meas_up_pkt_fwd	inc/stats.h	/^	uint32_t meas_up_pkt_fwd;$/;"	m	struct:statistics_uplink
mix	src/ghost.c	/^} mix;$/;"	t	typeref:union:__anon1	file:
moveave	src/stats.c	/^static double moveave(double old, uint32_t utel, uint32_t unoe) {$/;"	f	file:
mx_concent	src/dragino_gw_fwd.c	/^pthread_mutex_t mx_concent = PTHREAD_MUTEX_INITIALIZER;	\/* control access to the concentrator *\/$/;"	v
mx_jit_queue	src/jitqueue.c	/^static pthread_mutex_t mx_jit_queue = PTHREAD_MUTEX_INITIALIZER;	\/* control access to JIT queue *\/$/;"	v	file:
mx_meas_dw	src/dragino_gw_fwd.c	/^pthread_mutex_t mx_meas_dw = PTHREAD_MUTEX_INITIALIZER;	\/* control access to the downstream measurements *\/$/;"	v
mx_meas_gps	src/dragino_gw_fwd.c	/^pthread_mutex_t mx_meas_gps = PTHREAD_MUTEX_INITIALIZER;	\/* control access to the GPS statistics *\/$/;"	v
mx_meas_up	src/dragino_gw_fwd.c	/^pthread_mutex_t mx_meas_up = PTHREAD_MUTEX_INITIALIZER;	\/* control access to the upstream measurements *\/$/;"	v
mx_queue	inc/transport.h	/^	pthread_mutex_t mx_queue;	\/\/ control access to the queue for each server$/;"	m	struct:_server
mx_rxqueue	src/dragino_gw_fwd.c	/^pthread_mutex_t mx_rxqueue = PTHREAD_MUTEX_INITIALIZER;	\/* control access to the queues *\/$/;"	v
mx_stat_rep	src/dragino_gw_fwd.c	/^pthread_mutex_t mx_stat_rep = PTHREAD_MUTEX_INITIALIZER;	\/* control access to the status report *\/$/;"	v
mx_timeref	src/dragino_gw_fwd.c	/^pthread_mutex_t mx_timeref = PTHREAD_MUTEX_INITIALIZER;	\/* control access to GPS time reference *\/$/;"	v
mx_timersync	src/timersync.c	/^static pthread_mutex_t mx_timersync = PTHREAD_MUTEX_INITIALIZER;	\/* control access to timer sync offsets *\/$/;"	v	file:
mx_xcorr	src/dragino_gw_fwd.c	/^pthread_mutex_t mx_xcorr = PTHREAD_MUTEX_INITIALIZER;	\/* control access to the XTAL correction *\/$/;"	v
names	src/parson.c	/^	char **names;$/;"	m	struct:json_object_t	file:
nbpkt	inc/transport.h	/^	int nbpkt;$/;"	m	struct:_queue
net_mac_h	src/semtech_transport.c	/^static uint32_t net_mac_h;		\/* Most Significant Nibble, network order *\/$/;"	v	file:
net_mac_l	src/semtech_transport.c	/^static uint32_t net_mac_l;		\/* Least Significant Nibble, network order *\/$/;"	v	file:
next	inc/transport.h	/^	struct _queue *next;$/;"	m	struct:_queue	typeref:struct:_queue::_queue
nodes	inc/jitqueue.h	/^	struct jit_node_s nodes[JIT_QUEUE_MAX];	\/* Nodes\/packets array in the queue *\/$/;"	m	struct:jit_queue_s	typeref:struct:jit_queue_s::jit_node_s
null	src/parson.c	/^	int null;$/;"	m	union:json_value_value	file:
num_beacon	inc/jitqueue.h	/^	uint8_t num_beacon;			\/* Number of beacons in the queue *\/$/;"	m	struct:jit_queue_s
num_bytes_in_utf8_sequence	src/parson.c	/^static int num_bytes_in_utf8_sequence(unsigned char c) {$/;"	f	file:
num_pkt	inc/jitqueue.h	/^	uint8_t num_pkt;			\/* Total number of packets in the queue (downlinks, beacons...) *\/$/;"	m	struct:jit_queue_s
number	src/parson.c	/^	double number;$/;"	m	union:json_value_value	file:
object	src/parson.c	/^	JSON_Object *object;$/;"	m	union:json_value_value	file:
offset_unix_concent	src/timersync.c	/^static struct timeval offset_unix_concent = { 0, 0 };	\/* timer offset between unix host and concentrator *\/$/;"	v	typeref:struct:timeval	file:
parse_SX1301_configuration	src/dragino_gw_fwd.c	/^static int parse_SX1301_configuration(const char *conf_file) {$/;"	f	file:
parse_array_value	src/parson.c	/^static JSON_Value *parse_array_value(const char **string, size_t nesting) {$/;"	f	file:
parse_boolean_value	src/parson.c	/^static JSON_Value *parse_boolean_value(const char **string) {$/;"	f	file:
parse_config	src/dragino_gw_fwd.c	/^static int parse_config(const char *conf_file) {$/;"	f	file:
parse_cplan_configuration	src/dragino_gw_fwd.c	/^static void parse_cplan_configuration(const char *conf_file) {$/;"	f	file:
parse_gateway_configuration	src/dragino_gw_fwd.c	/^static int parse_gateway_configuration(const char *conf_file) {$/;"	f	file:
parse_null_value	src/parson.c	/^static JSON_Value *parse_null_value(const char **string) {$/;"	f	file:
parse_number_value	src/parson.c	/^static JSON_Value *parse_number_value(const char **string) {$/;"	f	file:
parse_object_value	src/parson.c	/^static JSON_Value *parse_object_value(const char **string, size_t nesting) {$/;"	f	file:
parse_string_value	src/parson.c	/^static JSON_Value *parse_string_value(const char **string) {$/;"	f	file:
parse_utf_16	src/parson.c	/^static int parse_utf_16(const char **unprocessed, char **processed) {$/;"	f	file:
parse_value	src/parson.c	/^static JSON_Value *parse_value(const char **string, size_t nesting) {$/;"	f	file:
parson_free	src/parson.c	/^static JSON_Free_Function parson_free = free;$/;"	v	file:
parson_malloc	src/parson.c	/^static JSON_Malloc_Function parson_malloc = malloc;$/;"	v	file:
parson_parson_h	inc/parson.h	25;"	d
parson_strdup	src/parson.c	/^static char *parson_strdup(const char *string) {$/;"	f	file:
parson_strndup	src/parson.c	/^static char *parson_strndup(const char *string, size_t n) {$/;"	f	file:
pkt	inc/jitqueue.h	/^	struct lgw_pkt_tx_s pkt;	\/* TX packet *\/$/;"	m	struct:jit_node_s	typeref:struct:jit_node_s::lgw_pkt_tx_s
pkt_type	inc/jitqueue.h	/^	enum jit_pkt_type_e pkt_type;	\/* Packet type: Downlink, Beacon... *\/$/;"	m	struct:jit_node_s	typeref:enum:jit_node_s::jit_pkt_type_e
platform	src/dragino_gw_fwd.c	/^char platform[24] = DISPLAY_PLATFORM;	\/* platform definition *\/$/;"	v
port_down	inc/transport.h	/^	char port_down[8];			\/\/ downlink port for semtech proto$/;"	m	struct:_server
port_up	inc/transport.h	/^	char port_up[8];			\/\/ uplink port for semtech proto$/;"	m	struct:_server
post_delay	inc/jitqueue.h	/^	uint32_t post_delay;		\/* Amount of time after packet timestamp to be reserved (time on air) *\/$/;"	m	struct:jit_node_s
pre_delay	inc/jitqueue.h	/^	uint32_t pre_delay;			\/* Amount of time before packet timestamp to be reserved *\/$/;"	m	struct:jit_node_s
printBuffer	src/ghost.c	/^static void printBuffer(uint8_t * b, uint8_t len) {$/;"	f	file:
printRX	src/ghost.c	/^static void printRX(struct lgw_pkt_rx_s *p) {$/;"	f	file:
print_tx_status	src/dragino_gw_fwd.c	/^void print_tx_status(uint8_t tx_status) {$/;"	f
process_string	src/parson.c	/^static char *process_string(const char *input, size_t len) {$/;"	f	file:
pull_timeout	src/semtech_transport.c	/^static struct timeval pull_timeout = { 0, (PULL_TIMEOUT_MS * 1000) };	\/* non critical for throughput *\/$/;"	v	typeref:struct:timeval	file:
push_timeout_half	src/semtech_transport.c	/^static struct timeval push_timeout_half = { 0, (PUSH_TIMEOUT_MS * 500) };	\/* cut in half, critical for throughput *\/$/;"	v	typeref:struct:timeval	file:
push_timeout_ms	src/dragino_gw_fwd.c	/^long push_timeout_ms;$/;"	v
qsort_r	src/jitqueue.c	/^static void qsort_r(void *base, size_t nel, size_t width, __compar_d_fn_t comp,$/;"	f	file:
queue	inc/transport.h	/^	Queue *queue;				\/\/ queue of packets uplink data$/;"	m	struct:_server
queue	inc/transport.h	/^	Queue *queue;$/;"	m	struct:_tdarg
quit_sig	src/dragino_gw_fwd.c	/^volatile bool quit_sig = false;	\/* 1 -> application terminates without shutting down the hardware *\/$/;"	v
radiostream_enabled	src/dragino_gw_fwd.c	/^static bool radiostream_enabled = true;	\/* controls the data flow from radio-node to server       *\/$/;"	v	file:
readRX	src/ghost.c	/^static void readRX(struct lgw_pkt_rx_s *p, uint8_t * b) {$/;"	f	file:
read_file	src/parson.c	/^static char *read_file(const char *filename) {$/;"	f	file:
reference_coord	src/dragino_gw_fwd.c	/^struct coord_s reference_coord;$/;"	v	typeref:struct:coord_s
reference_coord	src/ghost.c	/^static struct coord_s reference_coord;$/;"	v	typeref:struct:coord_s	file:
remove_comments	src/parson.c	/^static void remove_comments(char *string, const char *start_token,$/;"	f	file:
report_ready	src/dragino_gw_fwd.c	/^bool report_ready = false;		\/* true when there is a new report to send to the server *\/$/;"	v
rxpkt_queue	src/dragino_gw_fwd.c	/^Queue *rxpkt_queue = NULL;$/;"	v
rxpkt_rec_sem	src/dragino_gw_fwd.c	/^sem_t rxpkt_rec_sem;$/;"	v
semtech	inc/transport.h	/^	semtech,$/;"	e	enum:server_type
semtech_init	src/semtech_transport.c	/^void semtech_init(int idx) {$/;"	f
semtech_stop	src/semtech_transport.c	/^void semtech_stop(int idx) {$/;"	f
semtech_thread_down	src/semtech_transport.c	/^void semtech_thread_down(void *pic) {$/;"	f
semtech_upstream	src/semtech_transport.c	/^void semtech_upstream(void *pic) {$/;"	f
send_sem	inc/transport.h	/^	sem_t send_sem;				\/\/ semaphore for sending data$/;"	m	struct:_server
send_tx_ack	src/semtech_transport.c	/^static int send_tx_ack(int ic, uint8_t token_h, uint8_t token_l,$/;"	f	file:
serv_count	src/dragino_gw_fwd.c	/^uint8_t serv_count = 0;			\/* Counter for defined servers *\/$/;"	v
server_type	inc/transport.h	/^enum server_type {$/;"	g
servers	src/dragino_gw_fwd.c	/^Server servers[MAX_SERVERS];	\/* Server information *\/$/;"	v
short_options	src/dragino_gw_fwd.c	/^static char *short_options = "c:l:s:d:h";$/;"	v	file:
sig_handler	src/dragino_gw_fwd.c	/^static void sig_handler(int sigio) {$/;"	f	file:
sighup_handler	src/dragino_gw_fwd.c	/^void sighup_handler() {$/;"	f
skip_quotes	src/parson.c	/^static JSON_Status skip_quotes(const char **string) {$/;"	f	file:
sock_down	inc/transport.h	/^	int sock_down;				\/\/ Semtech down socket$/;"	m	struct:_server
sock_ghost	src/ghost.c	/^static int sock_ghost;			\/* socket for downstream traffic *\/$/;"	v	file:
sock_up	inc/transport.h	/^	int sock_up;				\/\/ Semtech up socket$/;"	m	struct:_server
startup_time	src/stats.c	/^time_t startup_time;$/;"	v
stat_damping	src/dragino_gw_fwd.c	/^int stat_damping = 50;			\/* default damping for statistical values. *\/$/;"	v
stat_file	src/dragino_gw_fwd.c	/^char stat_file[1024] = "\\0";	\/* name \/ full path of file to store results in, off by default. *\/$/;"	v
stat_format	src/dragino_gw_fwd.c	/^char stat_format[32] = "semtech";	\/* format for json statistics. *\/$/;"	v
stat_interval	src/dragino_gw_fwd.c	/^static unsigned stat_interval = DEFAULT_STAT;	\/* time interval (in sec) at which statistics are collected and displayed *\/$/;"	v	file:
statistics_downlink	inc/stats.h	/^struct statistics_downlink {$/;"	s
statistics_uplink	inc/stats.h	/^struct statistics_uplink {$/;"	s
stats_data_up	src/stats.c	/^void stats_data_up(int nb_pkt, struct lgw_pkt_rx_s *rxpkt) {$/;"	f
stats_down	inc/stats.h	/^enum stats_down {$/;"	g
stats_init	src/stats.c	/^void stats_init() {$/;"	f
stats_report	src/stats.c	/^void stats_report() {$/;"	f
stats_up	inc/stats.h	/^enum stats_up {$/;"	g
status	inc/transport.h	/^	char *status;				\/\/ pointer to semtech status report$/;"	m	struct:_queue
status_report	src/dragino_gw_fwd.c	/^char status_report[STATUS_SIZE];	\/* status report as a JSON object *\/$/;"	v
statusstream	inc/transport.h	/^	bool statusstream;			\/\/ status stream enabled$/;"	m	struct:_server
statusstream_enabled	src/dragino_gw_fwd.c	/^bool statusstream_enabled = true;	\/* controls the data flow of status information to server *\/$/;"	v
string	src/parson.c	/^	char *string;$/;"	m	union:json_value_value	file:
swapcpy	src/endianext.c	/^void *swapcpy(void *dest, const void *src, size_t n) {$/;"	f
t_down	inc/transport.h	/^	pthread_t t_down;			\/\/ semtech down thread$/;"	m	struct:_server
t_up	inc/transport.h	/^	pthread_t t_up;				\/\/ upstream thread$/;"	m	struct:_server
thread_dispatch_rxpkt	src/dragino_gw_fwd.c	/^void thread_dispatch_rxpkt(void) {$/;"	f
thread_ghost	src/ghost.c	/^static void thread_ghost(void) {$/;"	f	file:
thread_gps	src/dragino_gw_fwd.c	/^void thread_gps(void) {$/;"	f
thread_jit	src/dragino_gw_fwd.c	/^void thread_jit(void) {$/;"	f
thread_rxpkt_enqueue	src/dragino_gw_fwd.c	/^void thread_rxpkt_enqueue(void *rxpkt_Q) {$/;"	f
thread_timersync	src/timersync.c	/^void thread_timersync(void) {$/;"	f
thread_up	src/dragino_gw_fwd.c	/^void thread_up(void) {$/;"	f
thread_valid	src/dragino_gw_fwd.c	/^void thread_valid(void) {$/;"	f
thread_watchdog	src/dragino_gw_fwd.c	/^void thread_watchdog(void) {$/;"	f
thrid_ghost	src/ghost.c	/^static pthread_t thrid_ghost;$/;"	v	file:
time_on_air	src/jitqueue.c	/^static uint32_t time_on_air(struct lgw_pkt_tx_s *packet, bool isBeacon) {$/;"	f	file:
time_reference_gps	src/dragino_gw_fwd.c	/^struct tref time_reference_gps;	\/* time reference used for UTC <-> timestamp conversion *\/$/;"	v	typeref:struct:tref
timersub	src/timersync.c	37;"	d	file:
tobecpy	src/endianext.c	/^void *tobecpy(void *dest, const void *src, size_t n) {$/;"	f
transport_init	src/transport.c	/^void transport_init() {$/;"	f
transport_send_downtraf	src/transport.c	/^void transport_send_downtraf(char *json, int len) {$/;"	f
transport_start	src/transport.c	/^void transport_start() {$/;"	f
transport_status	src/transport.c	/^void transport_status() {$/;"	f
transport_status_up	src/transport.c	/^void transport_status_up(uint32_t rx_rcv, uint32_t rx_ok, uint32_t tx_tot,$/;"	f
transport_stop	src/transport.c	/^void transport_stop() {$/;"	f
ttn	inc/transport.h	/^	TTN *ttn;					\/\/ TTN connection object$/;"	m	struct:_server
ttn_connect	src/ttn_transport.c	/^void ttn_connect(int idx) {$/;"	f
ttn_downlink	src/ttn_transport.c	/^void ttn_downlink(Router__DownlinkMessage * msg, __attribute__ ((unused))$/;"	f
ttn_dummy_downlink	src/ttn_transport.c	/^void ttn_dummy_downlink( __attribute__ ((unused)) Router__DownlinkMessage * msg,$/;"	f
ttn_gw_bridge	inc/transport.h	/^	ttn_gw_bridge,$/;"	e	enum:server_type
ttn_init	src/ttn_transport.c	/^void ttn_init(int idx) {$/;"	f
ttn_reconnect	src/ttn_transport.c	/^void ttn_reconnect(int idx) {$/;"	f
ttn_status	src/ttn_transport.c	/^void ttn_status(int idx) {$/;"	f
ttn_status_up	src/ttn_transport.c	/^void ttn_status_up(int idx, uint32_t rx_in, uint32_t rx_ok, uint32_t tx_in,$/;"	f
ttn_stop	src/ttn_transport.c	/^void ttn_stop(int idx) {$/;"	f
ttn_upstream	src/ttn_transport.c	/^void ttn_upstream(void *pic) {$/;"	f
tx_freq_max	src/dragino_gw_fwd.c	/^uint32_t tx_freq_max[LGW_RF_CHAIN_NB];	\/* highest frequency supported by TX chain *\/$/;"	v
tx_freq_min	src/dragino_gw_fwd.c	/^uint32_t tx_freq_min[LGW_RF_CHAIN_NB];	\/* lowest frequency supported by TX chain *\/$/;"	v
txlut	src/dragino_gw_fwd.c	/^struct lgw_tx_gain_lut_s txlut;	\/* TX gain table *\/$/;"	v	typeref:struct:lgw_tx_gain_lut_s
type	inc/transport.h	/^	enum server_type type;		\/\/ type of server$/;"	m	struct:_server	typeref:enum:_server::server_type
type	src/parson.c	/^	JSON_Value_Type type;$/;"	m	struct:json_value_t	file:
u	src/ghost.c	/^	uint32_t u;$/;"	m	union:__anon1	file:
u16	src/ghost.c	/^static uint16_t u16(uint8_t * p, uint8_t i) {$/;"	f	file:
u32	src/ghost.c	/^static uint32_t u32(uint8_t * p, uint8_t i) {$/;"	f	file:
u8	src/ghost.c	/^static uint8_t u8(uint8_t * p, uint8_t i) {$/;"	f	file:
uplink	src/stats.c	/^struct statistics_uplink uplink;$/;"	v	typeref:struct:statistics_uplink
upstream	inc/transport.h	/^	bool upstream;				\/\/ upstream enabled$/;"	m	struct:_server
upstream_enabled	src/dragino_gw_fwd.c	/^bool upstream_enabled = true;	\/* controls the data flow from end-node to server         *\/$/;"	v
usage	src/dragino_gw_fwd.c	/^void usage(char *proc_name) {$/;"	f
value	src/parson.c	/^	JSON_Value_Value value;$/;"	m	struct:json_value_t	file:
values	src/parson.c	/^	JSON_Value **values;$/;"	m	struct:json_object_t	file:
verify_utf8_sequence	src/parson.c	/^static int verify_utf8_sequence(const unsigned char *string, int *len) {$/;"	f	file:
wd_enabled	src/dragino_gw_fwd.c	/^bool wd_enabled = false;		\/* watchdog enabled                                 *\/$/;"	v
xtal_correct	src/dragino_gw_fwd.c	/^double xtal_correct = 1.0;$/;"	v
xtal_correct_ok	src/dragino_gw_fwd.c	/^bool xtal_correct_ok = false;	\/* set true when XTAL correction is stable enough *\/$/;"	v
